set encoding=utf-8

set nocompatible  " break vi compatibility
set modelines=0   " prevent file exploit
set title         " change terminal/window title to buffer name

syntax on                  " code highlight
filetype on                " detect file type
filetype plugin on         " use specific filetype plugins
filetype plugin indent on
runtime macros/matchit.vim " activate matchit (extended '%' behavior)

:silent !mkdir -p /tmp/vim/undo >/dev/null 2>&1
set nobackup              " ⚠  beware here: no backup
set noswapfile            " ⚠  beware here: no swap (so no .~foo on disk!)
set undodir=/tmp/vim/undo " ⚠  undodir will be killed upon restart
set undofile
set history=1000
set undolevels=1000

let mapleader = ","

" pathogen
call pathogen#infect()
call pathogen#helptags()


""""""" look'n'feel

colorscheme wombat256mod
set guifont=Anonymice\ Powerline\ for\ Powerline:h14

" vim-airline (status bar)
let g:airline_theme='wombat'
let g:airline_powerline_fonts=1
set laststatus=2
set t_Co=256
let g:airline#extensions#tabline#enabled=1     " display list of opened buffers
let g:airline#extensions#tabline#fnamemod=':t' " display buffer filename only

" display side file explorer
let g:netrw_liststyle = 3
let g:netrw_winsize   = 15
let g:netrw_banner    = 0
nmap <leader>d :Lex<CR> " This will toggle the file explorer on/off

" syntastic
set statusline+=%#warningmsg#                " from the documentation
set statusline+=%{SyntasticStatuslineFlag()} " from the documentation
set statusline+=%*                           " from the documentation
let g:syntastic_always_populate_loc_list  = 1
let g:syntastic_auto_loc_list             = 1
let g:syntastic_check_on_open             = 1
let g:syntastic_check_on_wq               = 1
let g:syntastic_aggregate_errors          = 1 " run all checkers no matter what
let g:syntastic_auto_jump                 = 0 " jump to first error upon save
let g:syntastic_python_checkers           = ['flake8']
let g:syntastic_python_flake8_args        = "--max-line-length=119"
let g:syntastic_cpp_compiler              = 'g++'
let g:syntastic_cpp_compiler_options      = '-Wall'
let g:syntastic_cpp_check_header          = 1
let g:syntastic_cpp_auto_refresh_includes = 1
let g:syntastic_javascript_checkers       = ['eslint']
let g:syntastic_mode_map                  = { "mode": "passive", "active_filetypes": ["python", "cpp"], "passive_filetypes": [] }

" git gutter
nmap <leader>g :GitGutterToggle
highlight SignColumn guibg=gray17
let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0


""""""" code layout

au BufRead,BufNewFile *.json set filetype=javascript               " json
au BufRead,BufNewFile * if &syntax == '' | set filetype=c | endif  " no extension filetype from http://stackoverflow.com/a/2669295/626278
au BufRead,BufNewFile *.tex setlocal ts=2 sw=2

" automatically reload vim configuration when a change is detected (http://superuser.com/a/417997)
augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
augroup END

" indentation
set autoindent
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set textwidth=0
set colorcolumn=100
set scrolloff=5 " always show at least 5 lines below
set formatoptions+=qrn1
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif
set shiftround        " round indent to multiple of shiftwidth
set showcmd           " display current command (nice for <leader>)
set showmatch         " show matching brackets
set showmode
set wrap
set linebreak         " change long lines display
set visualbell        " enable visual bell instead of audio bell
set cursorline        " highlight current line
set ttyfast
set ruler             " show line/column in footer
set gdefault          " set g by default for substitute commands (%s///g)
set clipboard=unnamed " use the system clipboard

" trailing spaces (no automatic killing of them though)
highlight TrailingSpaces ctermbg=red guibg=red
match TrailingSpaces /\s\+$\|\t/

" editing
set hidden                     " allow unsaved changes in buffer
set backspace=indent,eol,start " low backspacing over an indent, line break (end of line) or start of an insert

" searching
""" files
set wildignorecase " case insensitive file completion
set wildmenu       " bash-like tab completion
set wildmode=list:longest,full
set wildignore+=*.o,*.so,*.swp,*.zip,*.pyc,*/vendor/*,*/node_modules/*

" The Silver Searcher
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor
  " Use project root for ag search by default
  let g:ag_working_path_mode='r'
  let g:ag_prg='ag --vimgrep --smart-case '
  nnoremap <silent> <leader>f :Ag!<space>
endif


:silent !mkdir -p /tmp/vim/cache/unite >/dev/null 2>&1
let g:unite_data_directory = '/tmp/vim/cache/unite'
let g:unite_enable_start_insert = 1
" search files 'à la' Ctrl-P using Unite
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_length'])
call unite#custom#source('file_rec/async','sorters','sorter_rank')
" search from project root
nnoremap <silent> <leader>p :UniteWithProjectDir -auto-resize buffer file_rec/async:!<cr>
" bind F to grep word under cursor (see https://robots.thoughtbot.com/faster-grepping-in-vim)
nnoremap F :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>


""" within buffer
set ignorecase
set smartcase
set incsearch
set hlsearch

"clear highlight on 'return'
nnoremap <silent> <CR> :noh<CR>

" use visual selection as (forward) search
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>



""""""" navigation

" navigate through buffers using ctrl-h & ctrl-l in normal/insert modes
nnoremap <C-h> :bprevious<CR>
nnoremap <C-l> :bnext<CR>
inoremap <C-h> <Esc>:bprevious<CR>i
inoremap <C-l> <Esc>:bnext<CR>i
nnoremap <C-x> :bd<CR>

" navigate through splits using arrows
nmap <silent> <S-Up> :wincmd k<CR>
nmap <silent> <S-Down> :wincmd j<CR>
nmap <silent> <S-Left> :wincmd h<CR>
nmap <silent> <S-Right> :wincmd l<CR>




"""""" utilities

" git commit messages with spelling and automatic insert mode
if has("spell")
  au BufNewFile,BufRead COMMIT_EDITMSG setlocal spell
endif
au BufNewFile,BufRead COMMIT_EDITMSG call feedkeys("i", "t")

" taglist
nnoremap <leader>t :TlistToggle<CR>
let Tlist_Use_Right_Window = 1

" toggle comment on current line/visual selection
map <leader>c :TComment<CR>

" replace current line by the result of executing the command in a shell
nnoremap <Leader>x !!sh<cr>

" prettify json
function! DoPrettyJSON()
  let l:origft = &ft
  silent %!python -m json.tool
  exe "set ft=" . l:origft
endfunction
command! PrettyJSON call DoPrettyJSON()

" prettify xml
function! DoPrettyXML()
  let l:origft = &ft
  set ft=
  1s/<?xml .*?>//e
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  2d
  $d
  silent %<
  1
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()


" rename current file
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'))
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
map <leader>w :call RenameFile()<cr>


" see http://vimcasts.org/episodes/aligning-text-with-tabular-vim/ for details
nmap <Leader>a= :Tabularize /=<CR>
vmap <Leader>a= :Tabularize /=<CR>
nmap <Leader>a: :Tabularize /:\zs<CR>
vmap <Leader>a: :Tabularize /:\zs<CR>

inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
function! s:align()
    let p = '^\s*|\s.*\s|\s*$'
    if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
        let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
        let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
        Tabularize/|/l1
        normal! 0
        call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
    endif
endfunction


" function! RunTests(filename)
"   " Write the file and run tests for the given filename
"   :w
"   :silent !clear
"   if match(a:filename, '\.feature$') != -1
"     exec ":!bundle exec cucumber " . a:filename
"   elseif match(a:filename, '_test\.rb$') != -1
"     if filereadable("script/testrb")
"       exec ":!script/testrb " . a:filename
"     else
"       exec ":!ruby -Itest " . a:filename
"     end
"   else
"     if filereadable("Gemfile")
"       exec ":!bundle exec rspec --color " . a:filename
"     else
"       exec ":!rspec --color " . a:filename
"     end
"   end
" endfunction


" singlecompile shortcuts
nmap <F5> :SCCompile<cr>
nmap <F6> :SCCompileRun<cr>
" use g++ with C++11 support as default C++ compiler
call SingleCompile#SetCompilerTemplate('cpp', 'c++11', 'g++ with C++11 support',
                                      \'clang++', '-std=c++11 -stdlib=libc++ -Wall -o $(FILE_TITLE)$',
                                      \'echo -e "\n---\nOutput:\n" && ./$(FILE_TITLE)$')
call SingleCompile#SetOutfile('cpp', 'c++11', '$(FILE_TITLE)$')
call SingleCompile#ChooseCompiler('cpp', 'c++11')


" " autocomplete
" need bundle: 'Shougo/neocomplcache'
" let g:acp_enableAtStartup              = 0
" let g:neocomplcache_enable_at_startup  = 1
" let g:neocomplcache_enable_smart_case  = 1
" let g:neocomplcache_min_syntax_length  = 2
" let g:neocomplcache_enable_auto_select = 1
" let g:neocomplcache_max_list           = 12
" let g:neocomplcache_enable_camel_case_completion = 1
" let g:neocomplcache_enable_underbar_completion   = 1
