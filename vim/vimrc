set encoding=utf-8
set nocompatible  " break vi compatibility

let mapleader = ","

" Plugins install
call plug#begin('~/.vim/plugged')

Plug 'https://github.com/vim-scripts/wombat256.vim'
Plug 'https://github.com/tpope/vim-fugitive'
Plug 'https://github.com/henrik/vim-indexed-search'
Plug 'https://github.com/Raimondi/delimitMate'
Plug 'https://github.com/sheerun/vim-polyglot'
Plug 'https://github.com/majutsushi/tagbar'

Plug 'https://github.com/godlygeek/tabular'
"{{{
" see http://vimcasts.org/episodes/aligning-text-with-tabular-vim/ for details
nmap <Leader>a= :Tabularize /=<CR>
vmap <Leader>a= :Tabularize /=<CR>
nmap <Leader>a: :Tabularize /:\zs<CR>
vmap <Leader>a: :Tabularize /:\zs<CR>

inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
function! s:align()
    let p = '^\s*|\s.*\s|\s*$'
    if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
        let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
        let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
        Tabularize/|/l1
        normal! 0
        call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
    endif
endfunction
"}}}

Plug 'https://github.com/tomtom/tcomment_vim'
"{{{
  " toggle comment on current line/visual selection
  map <leader>c :TComment<CR>
"}}}

Plug 'https://github.com/bling/vim-airline'
Plug 'https://github.com/vim-airline/vim-airline-themes'
"{{{
" vim-airline (status bar)
  let g:airline_theme='wombat'
  let g:airline_powerline_fonts=1
  set laststatus=2
  set t_Co=256
  let g:airline#extensions#tabline#enabled=1     " display list of opened buffers
  let g:airline#extensions#tabline#fnamemod=':t' " display buffer filename only
"}}}

Plug 'https://github.com/xuhdev/SingleCompile'
"{{{
" singlecompile shortcuts
  nmap <F5> :SCCompile<cr>
  nmap <F6> :SCCompileRun<cr>
  " use g++ with C++11 support as default C++ compiler
  call SingleCompile#SetCompilerTemplate('cpp', 'c++', 'g++ with C++11 support',
                                        \'clang++', '-std=c++11 -stdlib=libc++ -Wall -o $(FILE_TITLE)$',
                                        \'echo -e "\n---\nOutput:\n" && ./$(FILE_TITLE)$')
  call SingleCompile#SetOutfile('cpp', 'c++', '$(FILE_TITLE)$')
  call SingleCompile#ChooseCompiler('cpp', 'c++')
"}}}

Plug 'https://github.com/Shougo/vimproc.vim', { 'do': 'make' }
Plug 'https://github.com/Shougo/neomru.vim'
Plug 'https://github.com/Shougo/unite.vim'
"{{{
  :silent !mkdir -p ~/.vim/udata/cache/unite >/dev/null 2>&1
  let g:unite_data_directory = '~/.vim/udata/cache/unite'
  let g:unite_enable_start_insert = 1
  " search files 'Ã  la' Ctrl-P using Unite
  call unite#filters#matcher_default#use(['matcher_fuzzy'])
  call unite#filters#sorter_default#use(['sorter_length'])
  call unite#custom#source('file_rec/async','sorters','sorter_rank')
  " search from project root
  nnoremap <silent> <leader>p :UniteWithProjectDir -auto-resize buffer file_rec/async:!<cr>

  " The Silver Searcher
  if executable('ag')
      let g:unite_source_grep_command = 'ag'
      let g:unite_source_grep_default_opts = '--smart-case --vimgrep --hidden --ignore ''.git'' '
      let g:unite_source_grep_recursive_opt = ''
  elseif executable('ack')
    let g:unite_source_grep_command = 'ack'
    let g:unite_source_grep_default_opts = '--smart-case'
    let g:unite_source_grep_recursive_opt = ''
  endif
  nnoremap <silent> <leader>f :UniteWithProjectDir -auto-resize grep:::<cr>
"}}}

Plug 'https://github.com/airblade/vim-gitgutter'
"{{{
  highlight SignColumn guibg=gray17
  let g:gitgutter_realtime = 0
  let g:gitgutter_eager = 0
"}}}

Plug 'https://github.com/scrooloose/syntastic'
"{{{
  " set statusline+=%#warningmsg#                " from the documentation
  " set statusline+=%{SyntasticStatuslineFlag()} " from the documentation
  " set statusline+=%*                           " from the documentation

  " see also statusline updates
  let g:syntastic_always_populate_loc_list  = 1
  let g:syntastic_auto_loc_list             = 1
  let g:syntastic_check_on_open             = 1
  let g:syntastic_check_on_wq               = 1
  let g:syntastic_aggregate_errors          = 1 " run all checkers no matter what
  let g:syntastic_auto_jump                 = 0 " jump to first error upon save
  let g:syntastic_python_checkers           = ['flake8']
  let g:syntastic_python_flake8_args        = "--max-line-length=119"
  let g:syntastic_cpp_compiler              = 'g++'
  let g:syntastic_cpp_compiler_options      = '-Wall'
  let g:syntastic_cpp_check_header          = 1
  let g:syntastic_cpp_auto_refresh_includes = 1
  let g:syntastic_javascript_checkers       = ['eslint']
  let g:syntastic_mode_map                  = { 'mode': 'passive', 'active_filetypes': ['python', 'cpp'], 'passive_filetypes': [] }
"}}}


Plug 'https://github.com/Valloric/YouCompleteMe', { 'do': './install.py --clang-completer' }
"{{{
  let g:ycm_global_ycm_extra_conf='~/.vim/ycm_extra_conf.py'
  let g:ycm_show_diagnostics_ui=1
  let g:ycm_max_diagnostics_to_display=10
  nnoremap <leader>g :YcmCompleter GoTo<CR>
"}}}

call plug#end()  " required


set modelines=0   " prevent file exploit
set title         " change terminal/window title to buffer name
filetype on                " detect file type
runtime macros/matchit.vim " activate matchit (extended '%' behavior)

:silent !mkdir -p ~/.vim/udata/undo >/dev/null 2>&1
:silent !mkdir -p ~/.vim/udata/back >/dev/null 2>&1
set noswapfile
set backupdir=~/.vim/udata/back
set undodir=~/.vim/udata/undo
set undofile
set history=1000
set undolevels=1000
set confirm " warn for unsaved changes before exiting


""""""" look'n'feel

colorscheme wombat256mod
set guifont=Anonymous\ Pro\ for\ Powerline:h14

" display side file explorer
let g:netrw_liststyle = 3
let g:netrw_winsize   = 15
let g:netrw_banner    = 0
nmap <leader>d :Lex<CR> " This will toggle the file explorer on/off


""""""" code layout

au BufRead,BufNewFile *.json set filetype=javascript               " json
au BufRead * if search('\M-*-c++-*-', 'n', 1) | setlocal ft=cpp | endif
au BufRead,BufNewFile *.tex setlocal ts=2 sw=2

" automatically reload vim configuration when a change is detected (http://superuser.com/a/417997)
augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
augroup END

" indentation
set autoindent
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set textwidth=0
set colorcolumn=100
set scrolloff=5 " always show at least 5 lines below
set formatoptions+=qrn1
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif
set shiftround        " round indent to multiple of shiftwidth
set showcmd           " display current command (nice for <leader>)
set showmatch         " show matching brackets
set showmode
set wrap
set linebreak         " change long lines display
set visualbell        " enable visual bell instead of audio bell
set cursorline        " highlight current line
set ttyfast
set ruler             " show line/column in footer
set gdefault          " set g by default for substitute commands (%s///g)
set clipboard=unnamed " use the system clipboard

" trailing spaces (no automatic killing of them though)
highlight TrailingSpaces ctermbg=red guibg=red
match TrailingSpaces /\s\+$\|\t/

" editing
set hidden                     " allow unsaved changes in buffer
set backspace=indent,eol,start " low backspacing over an indent, line break (end of line) or start of an insert

" searching
""" files
if v:version >= 700
    try
        set wildignorecase " case insensitive file completion
    catch
    endtry
endif
set wildmenu       " bash-like tab completion
set wildmode=list:longest,full
set wildignore+=*.o,*.so,*.swp,*.zip,*.pyc,*/vendor/*,*/node_modules/*


""" within buffer
set ignorecase
set smartcase
set incsearch
set hlsearch

"clear highlight on 'return'
nnoremap <silent> <CR> :noh<CR>

" use visual selection as (forward) search
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>



""""""" navigation

" navigate through buffers using ctrl-h & ctrl-l in normal/insert modes
nnoremap <C-h> :bprevious<CR>
nnoremap <C-l> :bnext<CR>
inoremap <C-h> <Esc>:bprevious<CR>i
inoremap <C-l> <Esc>:bnext<CR>i
nnoremap <C-x> :bd<CR>

" navigate through splits using arrows
nmap <silent> <S-Up> :wincmd k<CR>
nmap <silent> <S-Down> :wincmd j<CR>
nmap <silent> <S-Left> :wincmd h<CR>
nmap <silent> <S-Right> :wincmd l<CR>


"""""" utilities

" git commit messages with spelling and automatic insert mode
if has("spell")
  au BufNewFile,BufRead COMMIT_EDITMSG setlocal spell
endif

" replace current line by the result of executing the command in a shell
nnoremap <Leader>x !!sh<cr>

" prettify json
function! DoPrettyJSON()
  let l:origft = &ft
  silent %!python -m json.tool
  exe "set ft=" . l:origft
endfunction
command! PrettyJSON call DoPrettyJSON()

" prettify xml
function! DoPrettyXML()
  let l:origft = &ft
  set ft=
  1s/<?xml .*?>//e
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  2d
  $d
  silent %<
  1
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()


" rename current file
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'))
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
map <leader>w :call RenameFile()<cr>


" function! RunTests(filename)
"   " Write the file and run tests for the given filename
"   :w
"   :silent !clear
"   if match(a:filename, '\.feature$') != -1
"     exec ":!bundle exec cucumber " . a:filename
"   elseif match(a:filename, '_test\.rb$') != -1
"     if filereadable("script/testrb")
"       exec ":!script/testrb " . a:filename
"     else
"       exec ":!ruby -Itest " . a:filename
"     end
"   else
"     if filereadable("Gemfile")
"       exec ":!bundle exec rspec --color " . a:filename
"     else
"       exec ":!rspec --color " . a:filename
"     end
"   end
" endfunction
