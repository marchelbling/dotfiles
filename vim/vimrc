set encoding=utf-8
set nocompatible  " break vi compatibility

let mapleader = ","

" Plugins install
call plug#begin('~/.vim/plugged')

Plug 'https://github.com/vim-scripts/wombat256.vim'
Plug 'https://github.com/tpope/vim-fugitive'
Plug 'https://github.com/henrik/vim-indexed-search'
Plug 'https://github.com/Raimondi/delimitMate'
Plug 'https://github.com/sheerun/vim-polyglot'
Plug 'https://github.com/majutsushi/tagbar'

Plug 'https://github.com/godlygeek/tabular'
"{{{
" see http://vimcasts.org/episodes/aligning-text-with-tabular-vim/ for details
nmap <Leader>a= :Tabularize /=<CR>
vmap <Leader>a= :Tabularize /=<CR>
nmap <Leader>a: :Tabularize /:\zs<CR>
vmap <Leader>a: :Tabularize /:\zs<CR>

inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
function! s:align()
    let p = '^\s*|\s.*\s|\s*$'
    if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
        let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
        let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
        Tabularize/|/l1
        normal! 0
        call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
    endif
endfunction
"}}}

Plug 'https://github.com/tomtom/tcomment_vim'
"{{{
  " toggle comment on current line/visual selection
  map <leader>c :TComment<CR>
"}}}

Plug 'https://github.com/bling/vim-airline'
Plug 'https://github.com/vim-airline/vim-airline-themes'
"{{{
" vim-airline (status bar)
  let g:airline_theme='wombat'
  let g:airline_powerline_fonts=1
  set laststatus=2
  set t_Co=256
  let g:airline#extensions#tabline#enabled=1     " display list of opened buffers
  let g:airline#extensions#tabline#fnamemod=':t' " display buffer filename only
"}}}

Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
" {{{
  let g:fzf_nvim_statusline = 0 " disable statusline overwriting

  nnoremap <silent> <leader>p :Files<CR>
  nnoremap <silent> <leader>f :execute 'Ag ' . input('Ag/')<CR>
  nnoremap <silent> <leader>. :AgIn

  nnoremap <silent> K :call SearchWordWithAg()<CR>
  vnoremap <silent> K :call SearchVisualSelectionWithAg()<CR>
  nnoremap <silent> <leader>gl :Commits<CR>
  nnoremap <silent> <leader>ga :BCommits<CR>

  function! SearchWordWithAg()
    execute 'Ag' expand('<cword>')
  endfunction

  function! SearchVisualSelectionWithAg() range
    let old_reg = getreg('"')
    let old_regtype = getregtype('"')
    let old_clipboard = &clipboard
    set clipboard&
    normal! ""gvy
    let selection = getreg('"')
    call setreg('"', old_reg, old_regtype)
    let &clipboard = old_clipboard
    execute 'Ag' selection
  endfunction

  function! SearchWithAgInDirectory(...)
    call fzf#vim#ag(join(a:000[1:], ' '), extend({'dir': a:1}, g:fzf#vim#default_layout))
  endfunction
  command! -nargs=+ -complete=dir AgIn call SearchWithAgInDirectory(<f-args>)
" }}}

Plug 'https://github.com/airblade/vim-gitgutter'
"{{{
  highlight SignColumn guibg=gray17
  let g:gitgutter_realtime = 0
  let g:gitgutter_eager = 0
"}}}

Plug 'https://github.com/Valloric/YouCompleteMe', { 'do': './install.py --clang-completer' }
"{{{
  let g:ycm_global_ycm_extra_conf='~/.vim/ycm_extra_conf.py'
  let g:ycm_autoclose_preview_window_after_insertion=1
  let g:ycm_show_diagnostics_ui=1
  let g:ycm_max_diagnostics_to_display=10
  nnoremap <leader>g :YcmCompleter GoTo<CR>
"}}}

call plug#end()  " required


set modelines=0   " prevent file exploit
set title         " change terminal/window title to buffer name
filetype on                " detect file type
runtime macros/matchit.vim " activate matchit (extended '%' behavior)

:silent !mkdir -p ~/.vim/udata/undo >/dev/null 2>&1
:silent !mkdir -p ~/.vim/udata/back >/dev/null 2>&1
set noswapfile
set backupdir=~/.vim/udata/back
set undodir=~/.vim/udata/undo
set undofile
set history=1000
set undolevels=1000
set confirm " warn for unsaved changes before exiting


""""""" look'n'feel

colorscheme wombat256mod
set guifont=Anonymous\ Pro\ for\ Powerline:h14

" display side file explorer
let g:netrw_liststyle = 3
let g:netrw_winsize   = 15
let g:netrw_banner    = 0
nmap <leader>d :Lex<CR> " This will toggle the file explorer on/off


""""""" code layout

au BufRead,BufNewFile *.json set filetype=javascript               " json
au BufRead * if search('\M-*-c++-*-', 'n', 1) | setlocal ft=cpp | endif
au BufRead,BufNewFile *.tex setlocal ts=2 sw=2

" automatically reload vim configuration when a change is detected (http://superuser.com/a/417997)
augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
augroup END

" indentation
set autoindent
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set textwidth=0
set colorcolumn=100
set scrolloff=5 " always show at least 5 lines below
set formatoptions+=qrn1
if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif
set shiftround        " round indent to multiple of shiftwidth
set showcmd           " display current command (nice for <leader>)
set showmatch         " show matching brackets
set showmode
set wrap
set linebreak         " change long lines display
set visualbell        " enable visual bell instead of audio bell
set cursorline        " highlight current line
set ttyfast
set ruler             " show line/column in footer
set gdefault          " set g by default for substitute commands (%s///g)
set clipboard=unnamed " use the system clipboard

" trailing spaces (no automatic killing of them though)
highlight TrailingSpaces ctermbg=red guibg=red
match TrailingSpaces /\s\+$\|\t/

" editing
set hidden                     " allow unsaved changes in buffer
set backspace=indent,eol,start " low backspacing over an indent, line break (end of line) or start of an insert

" searching
""" files
if v:version >= 700
    try
        set wildignorecase " case insensitive file completion
    catch
    endtry
endif
set wildmenu       " bash-like tab completion
set wildmode=list:longest,full
set wildignore+=*.o,*.so,*.swp,*.zip,*.pyc,*/vendor/*,*/node_modules/*


""" within buffer
set ignorecase
set smartcase
set incsearch
set hlsearch

"clear highlight on 'return'
nnoremap <silent> <CR> :noh<CR>

" use visual selection as (forward) search
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>



""""""" navigation

" navigate through buffers using ctrl-h & ctrl-l in normal/insert modes
nnoremap <C-h> :bprevious<CR>
nnoremap <C-l> :bnext<CR>
inoremap <C-h> <Esc>:bprevious<CR>i
inoremap <C-l> <Esc>:bnext<CR>i
nnoremap <C-x> :bd<CR>

" navigate through splits using arrows
nmap <silent> <S-Up> :wincmd k<CR>
nmap <silent> <S-Down> :wincmd j<CR>
nmap <silent> <S-Left> :wincmd h<CR>
nmap <silent> <S-Right> :wincmd l<CR>


"""""" utilities

" git commit messages with spelling and automatic insert mode
if has("spell")
  au BufNewFile,BufRead COMMIT_EDITMSG setlocal spell
endif

" replace current line by the result of executing the command in a shell
nnoremap <Leader>x !!sh<cr>

" prettify json
function! DoPrettyJSON()
  let l:origft = &ft
  silent %!python -m json.tool
  exe "set ft=" . l:origft
endfunction
command! PrettyJSON call DoPrettyJSON()

" prettify xml
function! DoPrettyXML()
  let l:origft = &ft
  set ft=
  1s/<?xml .*?>//e
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  2d
  $d
  silent %<
  1
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()


" function! RunTests(filename)
"   " Write the file and run tests for the given filename
"   :w
"   :silent !clear
"   if match(a:filename, '\.feature$') != -1
"     exec ":!bundle exec cucumber " . a:filename
"   elseif match(a:filename, '_test\.rb$') != -1
"     if filereadable("script/testrb")
"       exec ":!script/testrb " . a:filename
"     else
"       exec ":!ruby -Itest " . a:filename
"     end
"   else
"     if filereadable("Gemfile")
"       exec ":!bundle exec rspec --color " . a:filename
"     else
"       exec ":!rspec --color " . a:filename
"     end
"   end
" endfunction
